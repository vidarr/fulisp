\documentclass[12pt]{article}
\usepackage{amsmath}
\title{\LaTeX}
\date{}
\begin{document}


% Remember: Use Oxford English!

\section{Introduction}

\section{Goals}

\subsection{Principles}

\begin{itemize}
    \item Adhere to standards: Use Standard C, POSIX
    \item Try to provide standardized tests for each bit 
    \item Simple design. Optimize only if benefits can be proven.
    \item (Kind of follow-up to previous) Use lean interfaces (keep the headers
        small)
\end{itemize}

\section{Language Core}

\subsection{Reference}

The very core of the language that is actually dealt with by the \texttt{eval}
function consists of the functions shown in table \ref{tbl:CoreFunctions}.

\begin{table}[h]
    \centering
    \begin{tabular}{c|l}
        \texttt{QUOTE} & Prevents its argument from being evaluated \\
        \texttt{CONS} & \\
        \texttt{CAR} & \\
        \texttt{CDR} & \\
        \texttt{COND} & \\
        \texttt{CONS?} & \\
        \texttt{DEFINE} & Expects exactly two arguments. First argument is a
        symvol, second argument is any kind of expression. Creates a binding in
        the global environment, returns the expression bound.\\
        \texttt{BEGIN} & Expects a list of expressions. Evaluates each of these
        expressions in the order of their appearance. Returns the value of the last
        expression. \\
        \texttt{SET!} & \\
        \texttt{=} & \\
        \texttt{<} & \\
        \texttt{OR} & \\
        \texttt{AND} & \\
        \texttt{NOT} & \\
        \texttt{LAMBDA} & Creates a new unnamed closure. Expects exactly two
        arguments: First argument is a list of symbols, the second argument is a
        expression. If the returned closure is evaluated, these symbols will be
        bound to the arguments the closure is called with. The closure can be
        bound to a symbol and thus become a function as it is common.\\
        \texttt{+} & \\
        \texttt{*} & 
    \end{tabular}
    \caption{\label{tbl:CoreFunctions}}
\end{table}


\section{Basic Data Structures}

\subsection{Linked Lists}

\subsection{Last In - First Out - The Stack}

\subsection{Dictionaries - The Hash Table}


\section{Symbols}

\subsection{\texttt{NIL}}

\texttt{NIL} is general identified with the NULL-pointer. Whenever a
NULL-Pointer is encountered, it is interpreted to represent \texttt{NIL}.


\section{\texttt{lambda}}

\texttt{lambda} is represented by a structure that contains 

\begin{enumerate}
\item A list of symbols. These symbols will be inserted into the current symbol
table with the parameters of the lambda call as values. 
\item A pointer to a Block of code to be executed when being called.
\end{enumerate}

Whenever a lambda expression is called with parameters, the following steps will
be performed:

\begin{enumerate}
\item  the parameters' values are inserted into the current lookup table  with the 
symbols of the lambda function. If the symbols already exist within the table,
the symbols original values have to be saved.
\item The lambda values code block is executed.
\item The symbols original values are restored.
\end{enumerate}


\section{Symbol Tables}

\begin{enumerate}
\item There is one global Symbol table. This table contains \texttt{NIL} etc.
\item Other symbol tables can be created on demand, for example by package.
These symbol tables are inserted into the current symbol table.
\item If a package is entered, the current package is pushed onto a stack and
the symbol table of the package becomes the new one.
\end{enumerate}

Lookups are performed via

\begin{enumerate}
\item the symbol is looked up in the current lookup table.
\item If not found, the symbol table stack is searched for.
\item A name like \texttt{part1::part2::part3...} is split up into its parts. Then,
\texttt{part1} is looked up just as a normal symbol. If it does not resolve to a symbol
table, an error is produced. If it resolves to a symbol table, the other parts
\texttt{part2}, \texttt{part3} etc are looked up within this lookup table.
\end{enumerate}


\section{Input/Output}

Uttmost principle should be that if a expression is printed out, its textual
representation, fed back into the reader, should yield a equivalent expression,
that is the following relation should hold:

({\texttt READ} ({\texttt COERCE} {\texttt 'STRING} {\texttt EXPRESSION})) $\equiv$ {\texttt EXPRESSION}


\section{Optimisations}

\subsection{Memory Preallocation}

\subsubsection{Benchmark}


Compiled the REPL twice, once with memory preallocation enabled, once with
memory preallocation disabled.
Then started both REPLs in parallel, and evaluated one form subsequently in the
one REPL, then the other, repeated this several times.
The form to be evaluated is

\begin{verbatim}
    (CONS (CONS (CONS (CONS (CONS 
      (CONS (CONS (CONS (CONS (CONS 
        (CONS (CONS (CONS (CONS (CONS 
          (CONS (CONS (CONS (CONS (CONS 
            (CONS (CONS 0 1) 2)
          3) 4) 5) 6) 7) 8) 9) 10) 11) 12) 
        13) 14) 15) 16) 17) 
      18) 19) 20) 21) 22)
\end{verbatim}

Results are shown in table \ref{tbl:BMResultsMemPreallocation}.
As you can see, for this example we gain about 9\% of speed.
We will not ignore the fact that this example has been tailored for making
abundand memory requests.

\begin{table}
    \centering
    \begin{tabular}{r|c|c}
           & With  & Without \\
        \hline 
         1 & 22038 & 24153 \\
         2 & 22157 & 24841 \\
         3 & 22204 & 24377 \\
         4 & 22238 & 25251 \\
         5 & 22315 & 24141 \\
         6 & 22815 & 24792 \\
         7 & 22146 & 24134 \\
         8 & 22268 & 24498 \\
         9 & 21969 & 24489 \\
        10 & 21720 & 24750 \\
        \hline
        summary & 221870 & 245426 \\
        \hline
        average & 22187  & 24543
    \end{tabular}
    \caption{\label{tbl:BMResultsMemPreallocation} Ticks measured for evaluating
        the form given in the text, left with memory preallocation enabled, on
    the right disabled.}
\end{table}




\end{document}
